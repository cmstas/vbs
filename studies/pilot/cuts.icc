VBS3LepCuts::VBS3LepCuts(Arbol& arbol, Nano& nt, HEPCLI& cli, Cutflow& cutflow)
{
    initBranches(arbol);
    initGlobals(cutflow);

    bookkeeping = new Cut(
        "Bookkeeping",
        [&]()
        {
            arbol.setLeaf<int>("event", nt.event());
            arbol.setLeaf<float>("met", nt.MET_pt());
            return true;
        },
        [&]()
        {
            return cli.scale_factor*nt.genWeight();
        }
    );

    has_3leps_presel = new Cut(
        "Geq3LepPresel",
        [&]()
        {
            int n_lep_pt_gt_20 = 0;
            // Loop over electrons
            for (unsigned int i = 0; i < nt.nElectron(); ++i)
            {
                if (nt.Electron_pt().at(i) > 20) { n_lep_pt_gt_20++; }
            }
            // Loop over muons
            for (unsigned int i = 0; i < nt.nMuon(); ++i)
            {
                if (nt.Muon_pt().at(i) > 20) { n_lep_pt_gt_20++; }
            }
            return (n_lep_pt_gt_20 >= 3);
        }
    );

    select_leps = new Cut(
        "SelectLeptons",
        [&]()
        {
            // Lepton ID sf
            float lep_sf = 1.;
            // Percent errors (up/down) on sf
            float err_up = 0.;
            float err_dn = 0.;

            LorentzVectors good_lep_p4s = cutflow.globals.getVal<LorentzVectors>("good_lep_p4s");
            Integers good_lep_pdgIDs = cutflow.globals.getVal<Integers>("good_lep_pdgIDs");
            Integers good_lep_idxs = cutflow.globals.getVal<Integers>("good_lep_idxs");
            Integers good_lep_jet_idxs = cutflow.globals.getVal<Integers>("good_lep_jet_idxs");
            // Loop over electrons
            for (unsigned int i = 0; i < nt.nElectron(); ++i)
            {
                if (!ttH::electronID(i, ttH::IDveto, nt.year())) { continue; }
                LorentzVector el_p4 = nt.Electron_p4().at(i);
                // Store basic info
                good_lep_p4s.push_back(el_p4);
                good_lep_pdgIDs.push_back(-nt.Electron_charge().at(i)*11);
                good_lep_idxs.push_back(i);
                good_lep_jet_idxs.push_back(nt.Electron_jetIdx().at(i));
                if (cli.is_data) { continue; }
                /* FIXME: add lepton sf code
                // Get scale factor (and up/down variations)
                float el_eta = std::max(std::min(el_p4.eta(), 2.4999f), -2.4999f);
                float el_pt = el_p4.pt();
                // event --> reco
                lep_sf *= ttH::getElecRecoEffSFUL(el_eta, el_pt, nt.year());
                err_up += std::pow(ttH::getElecRecoEffSFULErr(el_eta, el_pt, nt.year()), 2);
                err_dn += std::pow(ttH::getElecRecoEffSFULErr(el_eta, el_pt, nt.year()), 2);
                // reco --> loose POG ID
                lep_sf *= ttH::getElecPOGLooseSF(el_eta, el_pt, nt.year());
                err_up += std::pow(ttH::getElecPOGLooseSFErr(el_eta, el_pt, nt.year()), 2);
                err_dn += std::pow(ttH::getElecPOGLooseSFErr(el_eta, el_pt, nt.year()), 2);
                // loose POG ID --> loose ttH ID --> tight ttH ID
                lep_sf *= ttH::getElecLooseSF(el_eta, el_pt, nt.year());
                lep_sf *= ttH::getElecTightSF(el_eta, el_pt, nt.year());
                err_up += std::pow(ttH::getElecTTHSFErr(el_eta, el_pt, nt.year(), true), 2);
                err_dn += std::pow(ttH::getElecTTHSFErr(el_eta, el_pt, nt.year(), false), 2);
                */
            }
            // Loop over muons
            for (unsigned int i = 0; i < nt.nMuon(); ++i)
            {
                if (!ttH::muonID(i, ttH::IDveto, nt.year())) { continue; }
                LorentzVector mu_p4 = nt.Muon_p4().at(i);
                // Store basic info
                good_lep_p4s.push_back(mu_p4);
                good_lep_pdgIDs.push_back(-nt.Muon_charge().at(i)*13);
                good_lep_idxs.push_back(i);
                good_lep_jet_idxs.push_back(nt.Muon_jetIdx().at(i));
                if (cli.is_data) { continue; }
                /* FIXME: add lepton sf code
                // Get scale factor (and up/down variations)
                float mu_eta = mu_p4.eta();
                float mu_pt = mu_p4.pt();
                // medium POG ID --> loose ttH ID --> tight ttH ID (NOTE: POG sf is folded into ttH sf)
                lep_sf *= ttH::getMuonLooseSF(mu_eta, mu_pt, nt.year());
                lep_sf *= ttH::getMuonTightSF(mu_eta, mu_pt, nt.year());
                err_up += std::pow(ttH::getMuonTTHSFErr(mu_eta, mu_pt, nt.year(), true), 2);
                err_dn += std::pow(ttH::getMuonTTHSFErr(mu_eta, mu_pt, nt.year(), false), 2);
                */
            }
            // Store lepton sf and its up/down variations
            if (!cli.is_data)
            {
                // Finish error computation
                err_up = std::sqrt(err_up);
                err_dn = std::sqrt(err_dn);
                arbol.setLeaf<float>("lep_sf", lep_sf);
                arbol.setLeaf<float>("lep_sf_up", lep_sf + err_up*lep_sf);
                arbol.setLeaf<float>("lep_sf_dn", lep_sf - err_dn*lep_sf);
            }
            cutflow.globals.setVal<LorentzVectors>("good_lep_p4s", good_lep_p4s);
            cutflow.globals.setVal<Integers>("good_lep_pdgIDs", good_lep_pdgIDs);
            cutflow.globals.setVal<Integers>("good_lep_idxs", good_lep_idxs);
            cutflow.globals.setVal<Integers>("good_lep_jet_idxs", good_lep_jet_idxs);
            return true;
        }
    );

    select_jets = new Cut(
        "SelectJets",
        [&]()
        {
            int n_loose_b_jets = 0;
            int n_medium_b_jets = 0;
            int n_tight_b_jets = 0;
            int n_jets_pt30 = 0;
            DeepJetTags good_jet_btags = cutflow.globals.getVal<DeepJetTags>("good_jet_btags");
            LorentzVectors good_jet_p4s = cutflow.globals.getVal<LorentzVectors>("good_jet_p4s");
            Integers good_jet_idxs = cutflow.globals.getVal<Integers>("good_jet_idxs");
            for (unsigned int jet_i = 0; jet_i < nt.nJet(); ++jet_i)
            {
                // Read jet p4
                LorentzVector jet_p4 = nt.Jet_p4().at(jet_i);
                /* FIXME: add JEC variation code
                // Apply up/down JECs
                if (jec_var == 1 || jec_var == -1)
                {
                    jec_unc->setJetEta(jet_p4.eta());
                    jec_unc->setJetPt(jet_p4.pt());
                    float jec_err = abs(jec_unc->getUncertainty(jec_var == 1))*jec_var;
                    jet_p4 *= (1. + jec_err);
                }
                */
                if (jet_p4.pt() < 20) { continue; }
                // Apply jet ID
                int jet_id = nt.Jet_jetId().at(jet_i);
                if (nt.year() == 2016 && jet_id < 1) { continue; }
                if (nt.year() > 2016 && jet_id < 2) { continue; }
                // Perform overlap check against leptons
                bool is_overlap = false;
                LorentzVectors good_lep_p4s = cutflow.globals.getVal<LorentzVectors>("good_lep_p4s");
                Integers good_lep_jet_idxs = cutflow.globals.getVal<Integers>("good_lep_jet_idxs");
                for (unsigned int lep_i = 0; lep_i < good_lep_p4s.size(); ++lep_i)
                {
                    int lep_jet_idx = good_lep_jet_idxs.at(lep_i);
                    if (lep_jet_idx == -999)
                    {
                        LorentzVector lep_p4 = good_lep_p4s.at(lep_i);
                        float dR = ROOT::Math::VectorUtil::DeltaR(lep_p4, jet_p4);
                        if (dR < 0.4)
                        {
                            is_overlap = true;
                            break;
                        }
                    }
                    else if (lep_jet_idx == int(jet_i))
                    {
                        is_overlap = true;
                        break;
                    }
                }
                if (is_overlap) { continue; }
                // Perform b-tagging (for b-veto); only possible for pt > 20 GeV and |eta| < 2.4
                bool is_btagged_loose = false;
                bool is_btagged_medium = false;
                bool is_btagged_tight = false;
                if (std::abs(jet_p4.eta()) < 2.4) 
                {
                    // Check DeepJet vs. working points in NanoCORE global config (gconf)
                    is_btagged_loose = nt.Jet_btagDeepFlavB().at(jet_i) > gconf.WP_DeepFlav_loose;
                    is_btagged_medium = nt.Jet_btagDeepFlavB().at(jet_i) > gconf.WP_DeepFlav_medium;
                    is_btagged_tight = nt.Jet_btagDeepFlavB().at(jet_i) > gconf.WP_DeepFlav_tight;
                }
                // Count b-tags and save jet info
                if (is_btagged_tight) 
                {
                    good_jet_btags.push_back(TightTag);
                    n_tight_b_jets++;
                }
                else if (is_btagged_medium)
                {
                    good_jet_btags.push_back(MediumTag);
                    n_medium_b_jets++;
                }
                else if (is_btagged_loose)
                {
                    good_jet_btags.push_back(LooseTag);
                    n_loose_b_jets++;
                }
                else
                {
                    good_jet_btags.push_back(NoTag);
                }
                // Save additional jet info
                n_jets_pt30++;
                good_jet_p4s.push_back(jet_p4);
                good_jet_idxs.push_back(jet_i);
            }
            cutflow.globals.setVal<DeepJetTags>("good_jet_btags", good_jet_btags);
            cutflow.globals.setVal<LorentzVectors>("good_jet_p4s", good_jet_p4s);
            cutflow.globals.setVal<Integers>("good_jet_idxs", good_jet_idxs);
            arbol.setLeaf<int>("n_loose_b_jets", n_loose_b_jets);
            arbol.setLeaf<int>("n_medium_b_jets", n_medium_b_jets);
            arbol.setLeaf<int>("n_tight_b_jets", n_tight_b_jets);
            arbol.setLeaf<int>("n_jets_pt30", n_jets_pt30);
            return true;
        }
    );

    geq_2_jets = new Cut(
        "Geq2JetsPtGeq30",
        [&]()
        {
            return arbol.getLeaf<int>("n_jets_pt30") >= 2;
        }
    );

    no_tight_b_jets = new Cut(
        "NoTightBJets",
        [&]()
        {
            return arbol.getLeaf<int>("n_tight_b_jets") == 0;
        }
    );

    select_vbs_jets_maxE = new Cut(
        "SelectVBSJets",
        [&]()
        {
            LorentzVectors good_jet_p4s = cutflow.globals.getVal<LorentzVectors>("good_jet_p4s");
            // Select VBS jet candidates
            std::vector<int> vbs_jet_cand_idxs;
            for (unsigned int jet_i = 0; jet_i < good_jet_p4s.size(); ++jet_i)
            {
                if (good_jet_p4s.at(jet_i).pt() >= 30.) { vbs_jet_cand_idxs.push_back(jet_i); }
            }
            if (vbs_jet_cand_idxs.size() < 2) { return false; }
            // Sort candidates by pt
            std::sort(
                vbs_jet_cand_idxs.begin(), vbs_jet_cand_idxs.end(),
                [&](int i, int j) -> bool { return good_jet_p4s.at(i).pt() > good_jet_p4s.at(j).pt(); }
            );
            // Process candidates
            std::pair<int, int> vbs_jet_idxs;
            if (vbs_jet_cand_idxs.size() == 2)
            {
                vbs_jet_idxs = std::make_pair(vbs_jet_cand_idxs.at(0), vbs_jet_cand_idxs.at(1));
            }
            else
            {
                // Collect jets in pos/neg eta hemispheres
                std::vector<int> vbs_pos_eta_jet_idxs;
                std::vector<int> vbs_neg_eta_jet_idxs;
                for (auto& jet_i : vbs_jet_cand_idxs)
                {
                    const LorentzVector& jet_p4 = good_jet_p4s.at(jet_i);
                    if (jet_p4.eta() >= 0)
                    {
                        vbs_pos_eta_jet_idxs.push_back(jet_i);
                    }
                    else
                    {
                        vbs_neg_eta_jet_idxs.push_back(jet_i);
                    }
                }
                // Sort the jets in each hemisphere by P
                std::sort(
                    vbs_pos_eta_jet_idxs.begin(), vbs_pos_eta_jet_idxs.end(),
                    [&](int i, int j) -> bool { return good_jet_p4s.at(i).P() > good_jet_p4s.at(j).P(); }
                );
                std::sort(
                    vbs_neg_eta_jet_idxs.begin(), vbs_neg_eta_jet_idxs.end(),
                    [&](int i, int j) -> bool { return good_jet_p4s.at(i).P() > good_jet_p4s.at(j).P(); }
                );
                // Select VBS jets
                if (vbs_pos_eta_jet_idxs.size() == 0)
                {
                    // All candidates are in the -eta hemisphere
                    vbs_jet_idxs = std::make_pair(vbs_neg_eta_jet_idxs.at(0), vbs_neg_eta_jet_idxs.at(1));
                }
                else if (vbs_neg_eta_jet_idxs.size() == 0)
                {
                    // All candidates are in the +eta hemisphere
                    vbs_jet_idxs = std::make_pair(vbs_pos_eta_jet_idxs.at(0), vbs_pos_eta_jet_idxs.at(1));
                }
                else
                {
                    // Take the leading candidate (in P) from each hemisphere
                    vbs_jet_idxs = std::make_pair(vbs_pos_eta_jet_idxs.at(0), vbs_neg_eta_jet_idxs.at(0));
                }
            }
            // Separate the two VBS jets into leading/trailing
            int ld_vbs_jet_idx;
            int tr_vbs_jet_idx;
            if (good_jet_p4s.at(vbs_jet_idxs.first).pt() > good_jet_p4s.at(vbs_jet_idxs.first).pt())
            {
                ld_vbs_jet_idx = vbs_jet_idxs.first;
                tr_vbs_jet_idx = vbs_jet_idxs.second;
            }
            else
            {
                ld_vbs_jet_idx = vbs_jet_idxs.second;
                tr_vbs_jet_idx = vbs_jet_idxs.first;
            }
            LorentzVector ld_vbs_jet_p4 = good_jet_p4s.at(ld_vbs_jet_idx);
            LorentzVector tr_vbs_jet_p4 = good_jet_p4s.at(tr_vbs_jet_idx);
            // Save VBS jet info
            cutflow.globals.setVal<LorentzVector>("ld_vbs_jet_p4", ld_vbs_jet_p4);
            cutflow.globals.setVal<int>("ld_vbs_jet_idx", ld_vbs_jet_idx);
            cutflow.globals.setVal<LorentzVector>("tr_vbs_jet_p4", tr_vbs_jet_p4);
            cutflow.globals.setVal<int>("tr_vbs_jet_idx", tr_vbs_jet_idx);
            arbol.setLeaf("M_jj", (ld_vbs_jet_p4 + tr_vbs_jet_p4).M());
            arbol.setLeaf("deta_jj", ld_vbs_jet_p4.eta() - tr_vbs_jet_p4.eta());
            arbol.setLeaf("dR_jj", ROOT::Math::VectorUtil::DeltaR(ld_vbs_jet_p4, tr_vbs_jet_p4));
            return true;
        }
    );

    has_3leps = new Cut(
        "Has3TightLepsPtGeq40",
        [&]()
        {
            LorentzVectors good_lep_p4s = cutflow.globals.getVal<LorentzVectors>("good_lep_p4s");
            Integers good_lep_pdgIDs = cutflow.globals.getVal<Integers>("good_lep_pdgIDs");
            Integers good_lep_idxs = cutflow.globals.getVal<Integers>("good_lep_idxs");
            int n_loose_leps = 0;
            Integers trilep_idxs;
            for (unsigned int good_lep_i = 0; good_lep_i < good_lep_p4s.size(); ++good_lep_i)
            {
                if (good_lep_p4s.at(good_lep_i).pt() < 40) { continue; }
                // Count loose and tight leptons
                unsigned int lep_i = good_lep_idxs.at(good_lep_i);
                int lep_pdgID = good_lep_pdgIDs.at(good_lep_i);
                switch (abs(lep_pdgID))
                {
                case 11:
                    if (ttH::electronID(lep_i, ttH::IDfakable, nt.year())) { n_loose_leps++; }
                    if (ttH::electronID(lep_i, ttH::IDtight, nt.year())) 
                    {
                        trilep_idxs.push_back(good_lep_i);
                    }
                    break;
                case 13:
                    if (ttH::muonID(lep_i, ttH::IDfakable, nt.year())) { n_loose_leps++; }
                    if (ttH::muonID(lep_i, ttH::IDtight, nt.year())) 
                    {
                        trilep_idxs.push_back(good_lep_i);
                    }
                    break;
                }
            }
            // Require 3 and only 3 leptons (all passing tight ID)
            if (trilep_idxs.size() != 3 || n_loose_leps != 3) { return false; }
            // Sort into leading, middling, and trailing
            std::sort(
                trilep_idxs.begin(), trilep_idxs.end(),
                [&](int i, int j) -> bool { return good_lep_p4s.at(i).pt() > good_lep_p4s.at(j).pt(); }
            );
            int ld_i = trilep_idxs.at(0); // leading
            int md_i = trilep_idxs.at(1); // middling
            int tr_i = trilep_idxs.at(2); // trailing
            int ld_pdgID = good_lep_pdgIDs.at(ld_i);
            int md_pdgID = good_lep_pdgIDs.at(md_i);
            int tr_pdgID = good_lep_pdgIDs.at(tr_i);
            arbol.setLeaf<int>("ld_lep_pdgID", ld_pdgID);
            arbol.setLeaf<int>("md_lep_pdgID", md_pdgID);
            arbol.setLeaf<int>("tr_lep_pdgID", tr_pdgID);
            LorentzVector ld_p4 = good_lep_p4s.at(ld_i);
            LorentzVector md_p4 = good_lep_p4s.at(md_i);
            LorentzVector tr_p4 = good_lep_p4s.at(tr_i);
            cutflow.globals.setVal<LorentzVector>("ld_lep_p4", ld_p4);
            cutflow.globals.setVal<LorentzVector>("md_lep_p4", md_p4);
            cutflow.globals.setVal<LorentzVector>("tr_lep_p4", tr_p4);
            arbol.setLeaf<float>("ld_lep_pt", ld_p4.pt());
            arbol.setLeaf<float>("md_lep_pt", md_p4.pt());
            arbol.setLeaf<float>("tr_lep_pt", tr_p4.pt());
            arbol.setLeaf<float>("ld_lep_eta", ld_p4.eta());
            arbol.setLeaf<float>("md_lep_eta", md_p4.eta());
            arbol.setLeaf<float>("tr_lep_eta", tr_p4.eta());
            arbol.setLeaf<float>("ld_lep_phi", ld_p4.phi());
            arbol.setLeaf<float>("md_lep_phi", md_p4.phi());
            arbol.setLeaf<float>("tr_lep_phi", tr_p4.phi());
            // Count SFOS pairs
            int n_SFOS = 0;
            if (isSFOS(ld_pdgID, md_pdgID)) { n_SFOS++; }
            else if (isSFOS(md_pdgID, tr_pdgID)) { n_SFOS++; }
            else if (isSFOS(tr_pdgID, ld_pdgID)) { n_SFOS++; }
            arbol.setLeaf<int>("n_SFOS_lep_pairs", n_SFOS);
            return true;
        }
    );

    has_3leps_0SFOS = new Cut(
        "Has3Leps0SFOS",
        [&]()
        {
            return arbol.getLeaf<int>("n_SFOS_lep_pairs") == 0;
        }
    );

    has_3leps_1SFOS = new Cut(
        "Has3Leps1SFOS",
        [&]()
        {
            return arbol.getLeaf<int>("n_SFOS_lep_pairs") == 1;
        }
    );

    Z_veto = new Cut(
        "ZVeto70to110GeV",
        [&]()
        {
            int ld_lep_pdgID = arbol.getLeaf<int>("ld_lep_pdgID");
            int md_lep_pdgID = arbol.getLeaf<int>("md_lep_pdgID");
            int tr_lep_pdgID = arbol.getLeaf<int>("tr_lep_pdgID");
            LorentzVector ld_lep_p4 = cutflow.globals.getVal<LorentzVector>("ld_lep_p4");
            LorentzVector md_lep_p4 = cutflow.globals.getVal<LorentzVector>("md_lep_p4");
            LorentzVector tr_lep_p4 = cutflow.globals.getVal<LorentzVector>("tr_lep_p4");
            float Z_hyp_mass;
            if (isSFOS(ld_lep_pdgID, md_lep_pdgID)) 
            { 
                Z_hyp_mass = (ld_lep_p4 + md_lep_p4).M();
            }
            else if (isSFOS(md_lep_pdgID, tr_lep_pdgID)) 
            {
                Z_hyp_mass = (md_lep_p4 + tr_lep_p4).M();
            }
            else if (isSFOS(tr_lep_pdgID, ld_lep_pdgID)) 
            {
                Z_hyp_mass = (tr_lep_p4 + ld_lep_p4).M();
            }
            else
            {
                return true;
            }
            return Z_hyp_mass > 110 || Z_hyp_mass < 70;
        }
    );

    has_3leps_2SFOS = new Cut(
        "Has3Leps2SFOS",
        [&]()
        {
            return arbol.getLeaf<int>("n_SFOS_lep_pairs") == 2;
        }
    );

    dummy = new Cut("DummyCut", [&]() { return true; });
}

void VBS3LepCuts::initBranches(Arbol& arbol)
{
    arbol.newBranch<int>("event", -999);
    arbol.newBranch<float>("met", -999);
    arbol.newBranch<float>("ht", -999);
    arbol.newBranch<float>("lep_sf", -999);
    arbol.newBranch<float>("lep_sf_up", -999);
    arbol.newBranch<float>("lep_sf_dn", -999);
    arbol.newBranch<int>("n_loose_b_jets", -999);
    arbol.newBranch<int>("n_medium_b_jets", -999);
    arbol.newBranch<int>("n_tight_b_jets", -999);
    arbol.newBranch<int>("n_jets_pt30", -999);
    arbol.newBranch<float>("M_jj", -999);
    arbol.newBranch<float>("deta_jj", -999);
    arbol.newBranch<float>("dR_jj", -999);
    arbol.newBranch<int>("ld_lep_pdgID", -999);
    arbol.newBranch<int>("md_lep_pdgID", -999);
    arbol.newBranch<int>("tr_lep_pdgID", -999);
    arbol.newBranch<float>("ld_lep_pt", -999);
    arbol.newBranch<float>("md_lep_pt", -999);
    arbol.newBranch<float>("tr_lep_pt", -999);
    arbol.newBranch<float>("ld_lep_eta", -999);
    arbol.newBranch<float>("md_lep_eta", -999);
    arbol.newBranch<float>("tr_lep_eta", -999);
    arbol.newBranch<float>("ld_lep_phi", -999);
    arbol.newBranch<float>("md_lep_phi", -999);
    arbol.newBranch<float>("tr_lep_phi", -999);
    arbol.newBranch<int>("n_SFOS_lep_pairs", -999);
}

void VBS3LepCuts::initGlobals(Cutflow& cutflow)
{
    cutflow.globals.newVar<LorentzVectors>("good_lep_p4s", {});
    cutflow.globals.newVar<Integers>("good_lep_pdgIDs", {});
    cutflow.globals.newVar<Integers>("good_lep_idxs", {});
    cutflow.globals.newVar<Integers>("good_lep_jet_idxs", {});

    cutflow.globals.newVar<LorentzVectors>("good_jet_p4s", {});
    cutflow.globals.newVar<Integers>("good_jet_idxs", {});
    cutflow.globals.newVar<DeepJetTags>("good_jet_btags", {});

    cutflow.globals.newVar<LorentzVector>("ld_vbs_jet_p4");
    cutflow.globals.newVar<LorentzVector>("tr_vbs_jet_p4");
    cutflow.globals.newVar<int>("ld_vbs_jet_idx");
    cutflow.globals.newVar<int>("tr_vbs_jet_idx");

    cutflow.globals.newVar<LorentzVector>("ld_lep_p4");
    cutflow.globals.newVar<LorentzVector>("md_lep_p4");
    cutflow.globals.newVar<LorentzVector>("tr_lep_p4");
}

bool VBS3LepCuts::isSFOS(int pdgID_1, int pdgID_2)
{
    return (pdgID_1 == (-1)*pdgID_2);
}
